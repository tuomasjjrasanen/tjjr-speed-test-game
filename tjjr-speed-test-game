#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Copyright (C) 2016 Tuomas Räsänen
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

import random
import sys

from PyQt4.QtCore import *
from PyQt4.QtGui import *

max_misclicks = 6

class GraphicsGlowEffect(QGraphicsEffect):

    def __init__(self, color):
        super().__init__()

        self.__color  = color
        self.__extent = 100

    def boundingRectFor(self, rect):
        return QRectF(
            rect.left()   - 1 * self.__extent,
            rect.top()    - 1 * self.__extent,
            rect.width()  + 2 * self.__extent,
            rect.height() + 2 * self.__extent)

    def draw(self, painter):
        sourcePixmap, sourceOffset = self.sourcePixmap(Qt.LogicalCoordinates)

        colorizeEffect = QGraphicsColorizeEffect()
        colorizeEffect.setColor(self.__color)

        colorizedPixmap = self.__applyEffectToPixmap(sourcePixmap, colorizeEffect, 0)

        blurEffect = QGraphicsBlurEffect()
        blurEffect.setBlurRadius(15)

        colorizedBlurredPixmap = self.__applyEffectToPixmap(colorizedPixmap,
                                                            blurEffect,
                                                            self.__extent)

        for i in range(5):
            position = sourceOffset - QPoint(self.__extent, self.__extent)
            painter.drawPixmap(position, colorizedBlurredPixmap)
            self.drawSource(painter)

    def __applyEffectToPixmap(self, sourcePixmap, effect, extent):
        if not sourcePixmap:
            return QPixmap()

        if not effect:
            return sourcePixmap

        scene  = QGraphicsScene()
        item   = QGraphicsPixmapItem()
        pixmap = QPixmap(sourcePixmap.width()  + 2 * extent,
                         sourcePixmap.height() + 2 * extent)

        item.setPixmap(sourcePixmap)
        item.setGraphicsEffect(effect)
        scene.addItem(item);
        pixmap.fill(Qt.transparent)
        scene.render(QPainter(pixmap), QRectF(),
                     QRectF(-extent, -extent, pixmap.width(), pixmap.height()))

        return pixmap

class ColorLedButton(QPushButton):

    def __init__(self, color, radius=50):
        super().__init__()

        self.__color     = color
        self.__radius    = radius
        self.__blinkTimerId = None
        colorName        = color.name()
        darkerColorName  = color.darker(500).name()
        lighterColorName = color.lighter(175).name()
        self.setFixedSize(QSize(radius * 2, radius * 2))
        self.setStyleSheet("""
ColorLedButton {
 background    : qlineargradient(x1:0, y1:-1.5, x2:0, y2:1.3,
                                 stop:0 %s, stop: 1 %s);
 border-style  : solid;
 border-width  : 1px;
 border-radius : %spx;
 border-color  : black;
}

ColorLedButton:pressed {
 background    : qlineargradient(x1:0, y1:0, x2:0, y2:3,
                                 stop:0 %s, stop: 1 %s);
 border-width  : 3px;
}

ColorLedButton[isLit="true"] {
 background    : qradialgradient(cx:0.5, cy:0.5, radius:0.8,
                                 fx:0.5, fy:0.5, stop:0 %s, stop: 1 %s);
}

ColorLedButton[isLit="true"]:pressed {
 background    : qradialgradient(cx:0.5, cy:0.5, radius:0.82,
                                 fx:0.55, fy:0.55, stop:0 %s, stop: 1 %s);
}
""" % (lighterColorName, darkerColorName, radius,
       darkerColorName, lighterColorName,
       lighterColorName, colorName,
       lighterColorName, colorName))

        self.setMask(QRegion(QRect(-2, -2, self.__radius * 2 + 6, self.__radius * 2 + 6), QRegion.Ellipse))
        self.setFocusPolicy(Qt.NoFocus)

    def switchOn(self):
        self.setGraphicsEffect(GraphicsGlowEffect(self.__color))
        self.setProperty("isLit", True)
        self.style().unpolish(self)
        self.style().polish(self)
        self.update()

    def switchOff(self):
        self.setGraphicsEffect(None)
        self.setProperty("isLit", False)
        self.style().unpolish(self)
        self.style().polish(self)
        self.update()

    def toggle(self):
        if self.isLit():
            self.switchOff()
        else:
            self.switchOn()

    def timerEvent(self, event):
        if event.timerId() == self.__blinkTimerId:
            self.toggle()
        super().timerEvent(event)

    def startBlinking(self, interval=550):
        self.switchOn()
        self.__blinkTimerId = self.startTimer(interval)

    def stopBlinking(self):
        self.killTimer(self.__blinkTimerId)
        self.__blinkTimerId = None
        self.switchOff()

    def isLit(self):
        return self.property("isLit")

    def reset(self):
        self.switchOff()
        self.setText('')

class ScoreCounter(QLabel):

    def __init__(self):
        super().__init__("0")

        font = QFont()
        font.setPointSize(48)
        self.setFont(font)
        self.setAlignment(Qt.AlignCenter)
        self.setFixedSize(QSize(160, 80))
        self.setStyleSheet("""
ScoreCounter {
 color            : green;
 background-color : black;
 border-style     : ridge;
 border-width     : 6px;
 border-color     : grey;
 border-radius    : 40;
}
        """)

    def increment(self):
        self.setText(str(int(self.text()) + 1))

    def reset(self):
        self.setText("0")

    def count(self):
        return int(self.text())

class Dashboard(QWidget):

    def __init__(self):
        super().__init__()

        self.buttons      = []
        self.__controller   = Controller()
        self.scoreCounter = ScoreCounter()

        layout              = QVBoxLayout(self)
        middleRowLayout     = QHBoxLayout()
        bottomRowLayout     = QHBoxLayout()

        middleRowLayout.addWidget(self.scoreCounter)

        bottomRowLayout.addStretch()
        for color in [QColor(255, 0, 0), QColor(0, 255, 0), QColor(0, 0, 255), QColor(255, 255, 0)]:
            button = ColorLedButton(color)
            self.buttons.append(button)
            bottomRowLayout.addSpacing(50)
            bottomRowLayout.addWidget(button)
            self.__controller.addButton(button)

        bottomRowLayout.addSpacing(50)
        bottomRowLayout.addStretch()

        layout.addLayout(middleRowLayout)
        layout.addSpacing(50)
        layout.addLayout(bottomRowLayout)
        layout.addSpacing(50)

        self.__controller.setScoreCounter(self.scoreCounter)

    def clickButton(self, i):
        self.buttons[i].animateClick()

    def reset(self):
        for button in self.buttons:
            button.reset()
        self.scoreCounter.reset()

class Controller(QObject):

    TIMEOUTS = range(1000, 475, -25)

    def __init__(self):
        super().__init__()

        self.__buttons      = []
        self.__dashboard    = None
        self.__scoreCounter = None
        self.__failButton   = None
        self.__failTicks    = 0
        self.__failTimerId  = None
        self.__gameTimerId  = None
        self.__misclicks    = 0

    def timerEvent(self, event):
        if event.timerId() == self.__failTimerId:
            self.__failTicks += 1
            self.__failButton.toggle()
            if self.__failTicks >= 10:
                self.killTimer(self.__failTimerId)
                self.__failTimerId = None

                for button in self.__buttons:
                    button.switchOn()
                    button.setText("Press to\nstart!")

            return

        for button in self.__buttons:
            if button.isLit():
                self.__gameOver(button, "Too slow!")
                return

        self.__buttons[random.randrange(len(self.__buttons))].switchOn()

        level, remainder = divmod(self.__scoreCounter.count(), 5)
        if remainder == 0 and level < len(Controller.TIMEOUTS) - 1:
            self.killTimer(self.__gameTimerId)
            self.__gameTimerId = self.startTimer(Controller.TIMEOUTS[level])

    def __gameOver(self, failButton, reason):
        self.__failButton = failButton
        self.__failButton.setText("%s\nGame over!" % reason)
        self.killTimer(self.__gameTimerId)
        self.__gameTimerId = None
        self.__failTimerId = self.startTimer(500)

    def addButton(self, button):
        button.clicked.connect(lambda: self.__buttonClicked(button))
        self.__buttons.append(button)
        button.switchOn()
        button.setText("Press to\nstart!")

    def __buttonClicked(self, button):
        if self.__failTimerId is not None:
            return

        if self.__gameTimerId is None:
            self.start()
            return

        if not button.isLit():
            self.__misclicks += 1
            if self.__misclicks > max_misclicks:
                button.switchOn()
                self.__gameOver(button, "Too many\nmisclicks!")
            return

        button.switchOff()
        self.__scoreCounter.increment()

    def setDashboard(self, dashboard):
        self.__dashboard = dashboard

    def setScoreCounter(self, scoreCounter):
        self.__scoreCounter = scoreCounter

    def start(self):
        for button in self.__buttons:
            button.switchOff()
            button.setText("")
        self.__scoreCounter.reset()
        self.__gameTimerId = self.startTimer(1000)
        self.__misclicks = 0
        self.__failButton = None
        self.__failTicks = 0

class MainWindow(QMainWindow):

    def __init__(self):
        super().__init__()

        self.__dashboard = Dashboard()

        self.setStyleSheet("background-color: #3f3f3f;")
        self.setCentralWidget(self.__dashboard)
        self.setWindowTitle("TJJR's Speed Test Game")
        self.setFixedSize(QSize(694, 356))

    def keyPressEvent(self, event):
        keys = [Qt.Key_Left, Qt.Key_Up, Qt.Key_Down, Qt.Key_Right]
        try:
            i = keys.index(event.key())
        except ValueError:
            super().keyPressEvent(event)
            return
        else:
            self.__dashboard.clickButton(i)

def main():
    app = QApplication(sys.argv)

    if app.argc() > 1:
        error_message = "ERROR: invalid number of arguments ({}), expected 0"
        print(error_message.format(app.argc() - 1), file=sys.stderr)
        return 1

    win = MainWindow()
    win.show()

    return app.exec_()

if __name__ == "__main__":
    sys.exit(main())
